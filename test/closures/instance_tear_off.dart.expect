library;
import self as self;
import "dart:core" as core;
import "dart:mock" as mock;

class C extends core::Object {
  field dynamic f = new self::Closure#C#f#function::•(null);
  constructor •() → void
    : super core::Object::•()
    ;
  get g() → dynamic {
    return new self::Closure#C#g#function::•(null);
  }
  method a() → dynamic {
    return "a";
  }
  method b(dynamic x) → dynamic {
    return x;
  }
  method c(dynamic x, [dynamic y = 2]) → dynamic {
    return x.+(y);
  }
  method d(dynamic x, {dynamic y = 2}) → dynamic {
    return x.+(y);
  }
  get /* from null */ a#get() → dynamic
    return new self::Closure#C#a::•(this);
  get /* from null */ b#get() → dynamic
    return new self::Closure#C#b::•(this);
  get /* from null */ c#get() → dynamic
    return new self::Closure#C#c::•(this);
  get /* from null */ d#get() → dynamic
    return new self::Closure#C#d::•(this);
}
class Closure#C#g#function extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field mock::Context context;
  constructor •(final mock::Context context) → dynamic
    : self::Closure#C#g#function::context = context
    ;
  method call(dynamic x) → dynamic {
    final mock::Context #contextParameter = |{
                                                "This is a temporary solution. In the VM, this will become an additional parameter.";
                                               => this.{self::Closure#C#g#function::context}
                                            }|;
    return "g(${x})";
  }
}
class Closure#C#a extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field self::C self;
  constructor •(final self::C self) → dynamic
    : self::Closure#C#a::self = self
    ;
  method call() → dynamic
    return this.{self::Closure#C#a::self}.{self::C::a}();
}
class Closure#C#b extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field self::C self;
  constructor •(final self::C self) → dynamic
    : self::Closure#C#b::self = self
    ;
  method call(dynamic x) → dynamic
    return this.{self::Closure#C#b::self}.{self::C::b}(x);
}
class Closure#C#c extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field self::C self;
  constructor •(final self::C self) → dynamic
    : self::Closure#C#c::self = self
    ;
  method call(dynamic x, [dynamic y = 2]) → dynamic
    return this.{self::Closure#C#c::self}.{self::C::c}(x, y);
}
class Closure#C#d extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field self::C self;
  constructor •(final self::C self) → dynamic
    : self::Closure#C#d::self = self
    ;
  method call(dynamic x, {dynamic y = 2}) → dynamic
    return this.{self::Closure#C#d::self}.{self::C::d}(x, y: y);
}
class Closure#C#f#function extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field mock::Context context;
  constructor •(final mock::Context context) → dynamic
    : self::Closure#C#f#function::context = context
    ;
  method call() → dynamic {
    final mock::Context #contextParameter = |{
                                                "This is a temporary solution. In the VM, this will become an additional parameter.";
                                               => this.{self::Closure#C#f#function::context}
                                            }|;
    return "f";
  }
}
static method expect(dynamic expected, dynamic actual) → dynamic {
  core::print("Expecting '${expected}' and got '${actual}'");
  if(!expected.==(actual)) {
    core::print("Expected '${expected}' but got '${actual}'");
    throw "Expected '${expected}' but got '${actual}'";
  }
}
static method main(dynamic arguments) → dynamic {
  dynamic c = new self::C::•();
  self::expect("f", c.f());
  self::expect("f", c.f.call());
  self::expect("g(42)", c.g(42));
  self::expect("g(42)", c.g.call(42));
  self::expect("a", c.a());
  self::expect("a", c.a#get.call());
  self::expect(42, c.b(42));
  self::expect(42, c.b#get.call(42));
  self::expect(42, c.c(40));
  self::expect(42, c.c#get.call(40));
  self::expect(87, c.c(80, 7));
  self::expect(87, c.c#get.call(80, 7));
  self::expect(42, c.d(40));
  self::expect(42, c.d#get.call(40));
  self::expect(87, c.d(80, y: 7));
  self::expect(87, c.d#get.call(80, y: 7));
}
