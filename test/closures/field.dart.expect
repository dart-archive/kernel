library;
import self as self;
import "dart:core" as core;
import "dart:mock" as mock;

class C extends core::Object {
  final field dynamic y = new self::Closure#0::•(null);
  static final field dynamic z = new self::Closure#1::•(null);
  constructor •() → void
    : super core::Object::•()
    ;
}
class Closure#0 extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field mock::Context context;
  constructor •(final mock::Context #t1) → dynamic
    : self::Closure#0::context = #t1
    ;
  method call() → dynamic {
    final mock::Context #t2 = |{
                                  "This is a temporary solution. In the VM, this will become an additional parameter.";
                                 => this.{self::Closure#0::context}
                              }|;
    return "y";
  }
}
class Closure#1 extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field mock::Context context;
  constructor •(final mock::Context #t3) → dynamic
    : self::Closure#1::context = #t3
    ;
  method call() → dynamic {
    final mock::Context #t4 = |{
                                  "This is a temporary solution. In the VM, this will become an additional parameter.";
                                 => this.{self::Closure#1::context}
                              }|;
    return "z";
  }
}
class Closure#2 extends core::Object implements core::Function { // from null
  field core::String note = "This is temporary. The VM doesn't need closure classes.";
  field mock::Context context;
  constructor •(final mock::Context #t5) → dynamic
    : self::Closure#2::context = #t5
    ;
  method call() → dynamic {
    final mock::Context #t6 = |{
                                  "This is a temporary solution. In the VM, this will become an additional parameter.";
                                 => this.{self::Closure#2::context}
                              }|;
    return "x";
  }
}
static field dynamic x = new self::Closure#2::•(null);
static method main() → dynamic {
  if(!"x".==(self::x.call()))
    throw "x";
  if(!"y".==(new self::C::•().y()))
    throw "y";
  if(!"z".==(self::C::z.call()))
    throw "z";
}
